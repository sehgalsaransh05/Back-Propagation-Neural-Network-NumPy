<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Back Propagation Neural Network from scratch using NumPy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="Back-Propagation-Neural-Network-NumPy_files/libs/clipboard/clipboard.min.js"></script>
<script src="Back-Propagation-Neural-Network-NumPy_files/libs/quarto-html/quarto.js"></script>
<script src="Back-Propagation-Neural-Network-NumPy_files/libs/quarto-html/popper.min.js"></script>
<script src="Back-Propagation-Neural-Network-NumPy_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Back-Propagation-Neural-Network-NumPy_files/libs/quarto-html/anchor.min.js"></script>
<link href="Back-Propagation-Neural-Network-NumPy_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Back-Propagation-Neural-Network-NumPy_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Back-Propagation-Neural-Network-NumPy_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Back-Propagation-Neural-Network-NumPy_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Back-Propagation-Neural-Network-NumPy_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Back Propagation Neural Network from scratch using NumPy</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>This notebook presents a hands-on approach to building a simple neural network from scratch using only <code>NumPy</code>, a fundamental library in Python known for its array operations and numerical computations. The focus is on understanding and manually implementing the core aspects of neural network training, including forward and backward propagation, without relying on higher-level frameworks like <em>TensorFlow</em> or <em>PyTorch</em>.</p>
</section>
<section id="imports" class="level2">
<h2 class="anchored" data-anchor-id="imports">Imports</h2>
<div id="c8ab30ea-e5c5-47d8-9425-dbf5714a7c9b" class="cell" data-tags="[]" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_iris</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OneHotEncoder</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>, message<span class="op">=</span><span class="st">"`sparse` was renamed to `sparse_output`"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="load-data" class="level2">
<h2 class="anchored" data-anchor-id="load-data">Load Data</h2>
<p>We will use the Iris dataset, which is a simple and commonly used dataset for classification.</p>
<div id="dcd35b36-0d56-42cc-a779-23f4a4ef6ae4" class="cell" data-tags="[]" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>iris <span class="op">=</span> load_iris()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> iris.data</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> iris.target.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)  <span class="co"># Reshape for one-hot encoding</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># One-hot encode targets</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>encoder <span class="op">=</span> OneHotEncoder(sparse<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> encoder.fit_transform(y)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Split data into training and test sets</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>X_train, X_test, Y_train, Y_test <span class="op">=</span> train_test_split(X, Y, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="data-visualization" class="level2">
<h2 class="anchored" data-anchor-id="data-visualization">Data Visualization</h2>
<p>Visualize the Iris dataset features to understand the distributio</p>
<div id="5e86b6ed-0c89-4340-a2f5-dd2e75f907a9" class="cell" data-tags="[]" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define colors and species labels</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'red'</span>]  </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>species <span class="op">=</span> [<span class="st">'Setosa'</span>, <span class="st">'Versicolor'</span>, <span class="st">'Virginica'</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array(y).flatten()</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, spec <span class="kw">in</span> <span class="bu">enumerate</span>(np.unique(y)):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y <span class="op">==</span> spec</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    plt.scatter(X[mask, <span class="dv">0</span>], X[mask, <span class="dv">1</span>], color<span class="op">=</span>colors[idx], label<span class="op">=</span>species[idx])</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Plot</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Sepal length'</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Sepal width'</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Iris Dataset - Sepal Length vs Sepal Width'</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>plt.legend(title<span class="op">=</span><span class="st">'Species'</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Back-Propagation-Neural-Network-NumPy_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="neural-network-implementation" class="level2">
<h2 class="anchored" data-anchor-id="neural-network-implementation">Neural Network Implementation</h2>
<p>We will implement a simple neural network with one hidden layer, using ReLU and Softmax activation functions, and backpropagation for learning.</p>
<section id="parameter-initialization" class="level4">
<h4 class="anchored" data-anchor-id="parameter-initialization">1. Parameter Initialization</h4>
<ul>
<li><strong>Purpose</strong>: Initialize network parameters (weights and biases) to small random values to prevent symmetry in learning.</li>
<li><strong>Function</strong>: <code>initialize_parameters(input_size, hidden_size, output_size)</code></li>
<li><strong>Details</strong>:
<ul>
<li><code>W1</code> and <code>W2</code>: Weight matrices for the hidden and output layers initialized with normal distribution scaled by 0.01.</li>
<li><code>b1</code> and <code>b2</code>: Bias vectors initialized to zeros.</li>
<li>Ensures that each neuron in a layer learns different features during training by starting with different initial values.</li>
</ul></li>
</ul>
<div id="53417678-d4ba-45e5-8d5e-282d7990f581" class="cell" data-tags="[]" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> initialize_parameters(input_size, hidden_size, output_size):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    W1 <span class="op">=</span> np.random.randn(hidden_size, input_size) <span class="op">*</span> <span class="fl">0.01</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    b1 <span class="op">=</span> np.zeros((hidden_size, <span class="dv">1</span>))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    W2 <span class="op">=</span> np.random.randn(output_size, hidden_size) <span class="op">*</span> <span class="fl">0.01</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    b2 <span class="op">=</span> np.zeros((output_size, <span class="dv">1</span>))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    parameters <span class="op">=</span> {<span class="st">"W1"</span>: W1, <span class="st">"b1"</span>: b1, <span class="st">"W2"</span>: W2, <span class="st">"b2"</span>: b2}</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parameters</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="activation-functions" class="level4">
<h4 class="anchored" data-anchor-id="activation-functions">2. Activation Functions</h4>
<ul>
<li><strong>ReLU (Rectified Linear Unit)</strong>:
<ul>
<li><strong>Function</strong>: <code>relu(Z)</code></li>
<li>Provides non-linearity in the decision function, allowing the model to learn more complex patterns.</li>
<li><strong>Derivative</strong>: <code>relu_derivative(Z)</code>, used during backpropagation to compute gradients.</li>
</ul></li>
<li><strong>Softmax</strong>:
<ul>
<li><strong>Function</strong>: <code>softmax(Z)</code></li>
<li>Normalizes the output to a probability distribution over predicted output classes, suitable for multi-class classification tasks.</li>
</ul></li>
</ul>
<div id="e1d3d6ef-90ed-4fca-a508-311b2703f622" class="cell" data-tags="[]" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> relu(Z):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.maximum(<span class="dv">0</span>, Z)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> relu_derivative(Z):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Z <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> softmax(Z):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    expZ <span class="op">=</span> np.exp(Z <span class="op">-</span> np.<span class="bu">max</span>(Z))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> expZ <span class="op">/</span> expZ.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="forward-propagation" class="level4">
<h4 class="anchored" data-anchor-id="forward-propagation">3. Forward Propagation</h4>
<ul>
<li><strong>Purpose</strong>: Compute the output of the network for a given input <code>X</code>.</li>
<li><strong>Function</strong>: <code>forward_propagation(X, parameters)</code></li>
<li><strong>Operations</strong>:
<ul>
<li>Linear transformations followed by activation functions (ReLU for hidden and Softmax for output layers).</li>
<li>Computes intermediate values <code>Z1</code>, <code>A1</code> (after ReLU), <code>Z2</code>, <code>A2</code> (after Softmax).</li>
</ul></li>
</ul>
<div id="ccdb225e-95ac-4973-a5a4-a77e335a75c1" class="cell" data-tags="[]" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> forward_propagation(X, parameters):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    W1 <span class="op">=</span> parameters[<span class="st">'W1'</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    b1 <span class="op">=</span> parameters[<span class="st">'b1'</span>]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    W2 <span class="op">=</span> parameters[<span class="st">'W2'</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    b2 <span class="op">=</span> parameters[<span class="st">'b2'</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    Z1 <span class="op">=</span> np.dot(W1, X) <span class="op">+</span> b1</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    A1 <span class="op">=</span> relu(Z1)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    Z2 <span class="op">=</span> np.dot(W2, A1) <span class="op">+</span> b2</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    A2 <span class="op">=</span> softmax(Z2)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    cache <span class="op">=</span> {<span class="st">"Z1"</span>: Z1, <span class="st">"A1"</span>: A1, <span class="st">"Z2"</span>: Z2, <span class="st">"A2"</span>: A2}</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A2, cache</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="cost-function" class="level4">
<h4 class="anchored" data-anchor-id="cost-function">4. Cost Function</h4>
<ul>
<li><strong>Purpose</strong>: Calculate the cross-entropy loss to evaluate the model’s performance.</li>
<li><strong>Function</strong>: <code>compute_cost(A2, Y)</code></li>
<li>Measures the performance of the classification model whose output is a probability value between 0 and 1.</li>
</ul>
<div id="ad96086a-6631-4cc0-b502-2ce9262c2a1f" class="cell" data-tags="[]" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_cost(A2, Y):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> Y.shape[<span class="dv">1</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    cost <span class="op">=</span> <span class="op">-</span>np.<span class="bu">sum</span>(np.log(A2) <span class="op">*</span> Y) <span class="op">/</span> m</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cost</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="backward-propagation" class="level4">
<h4 class="anchored" data-anchor-id="backward-propagation">5. Backward Propagation</h4>
<ul>
<li><strong>Purpose</strong>: Compute gradients necessary for learning the parameters via gradient descent.</li>
<li><strong>Function</strong>: <code>backward_propagation(parameters, cache, X, Y)</code></li>
<li><strong>Details</strong>:
<ul>
<li><code>dZ2</code>, <code>dW2</code>, <code>db2</code>: Gradients of loss with respect to output layer’s weights and biases.</li>
<li><code>dZ1</code>, <code>dW1</code>, <code>db1</code>: Gradients of loss with respect to hidden layer’s weights and biases.</li>
<li>Uses chain rule and derivatives of activation functions to propagate errors back through the network.</li>
</ul></li>
</ul>
<div id="52d25c66-d14e-4850-9be4-a76ed0b1bbd2" class="cell" data-tags="[]" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backward_propagation(parameters, cache, X, Y):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    W1 <span class="op">=</span> parameters[<span class="st">'W1'</span>]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    W2 <span class="op">=</span> parameters[<span class="st">'W2'</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    A1 <span class="op">=</span> cache[<span class="st">'A1'</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    A2 <span class="op">=</span> cache[<span class="st">'A2'</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> Y.shape[<span class="dv">1</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    dZ2 <span class="op">=</span> A2 <span class="op">-</span> Y</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    dW2 <span class="op">=</span> np.dot(dZ2, A1.T) <span class="op">/</span> m</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    db2 <span class="op">=</span> np.<span class="bu">sum</span>(dZ2, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>) <span class="op">/</span> m</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    dZ1 <span class="op">=</span> np.dot(W2.T, dZ2) <span class="op">*</span> relu_derivative(cache[<span class="st">'Z1'</span>])</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    dW1 <span class="op">=</span> np.dot(dZ1, X.T) <span class="op">/</span> m</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    db1 <span class="op">=</span> np.<span class="bu">sum</span>(dZ1, axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>) <span class="op">/</span> m</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    gradients <span class="op">=</span> {<span class="st">'dW1'</span>: dW1, <span class="st">'db1'</span>: db1, <span class="st">'dW2'</span>: dW2, <span class="st">'db2'</span>: db2}</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> gradients</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="update-parameters" class="level4">
<h4 class="anchored" data-anchor-id="update-parameters">6. Update Parameters</h4>
<ul>
<li><strong>Purpose</strong>: Adjust the parameters (<code>W1</code>, <code>W2</code>, <code>b1</code>, <code>b2</code>) using the gradients computed in backward propagation.</li>
<li><strong>Function</strong>: <code>update_parameters(parameters, gradients, learning_rate)</code></li>
<li>Updates each parameter in the direction that minimally reduces the error (loss function).</li>
</ul>
<div id="49a870de-f22e-4a90-8ce8-c0357959e221" class="cell" data-tags="[]" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_parameters(parameters, gradients, learning_rate):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    parameters[<span class="st">'W1'</span>] <span class="op">-=</span> learning_rate <span class="op">*</span> gradients[<span class="st">'dW1'</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    parameters[<span class="st">'b1'</span>] <span class="op">-=</span> learning_rate <span class="op">*</span> gradients[<span class="st">'db1'</span>]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    parameters[<span class="st">'W2'</span>] <span class="op">-=</span> learning_rate <span class="op">*</span> gradients[<span class="st">'dW2'</span>]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    parameters[<span class="st">'b2'</span>] <span class="op">-=</span> learning_rate <span class="op">*</span> gradients[<span class="st">'db2'</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parameters</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="model-training-and-evaluation-functions" class="level4">
<h4 class="anchored" data-anchor-id="model-training-and-evaluation-functions">7. Model Training and Evaluation Functions</h4>
<ul>
<li><strong>Model Training</strong>:
<ul>
<li>Encapsulates initialization, forward and backward propagation, and parameter updates over multiple iterations.</li>
</ul></li>
<li><strong>Prediction and Accuracy Calculation</strong>:
<ul>
<li>Uses the trained model to predict labels for new inputs and evaluates accuracy by comparing predicted labels to true labels.</li>
</ul></li>
<li><strong>Confusion Matrix and Precision-Recall-F1 Calculation</strong>:
<ul>
<li>Further metrics to evaluate model performance, including confusion matrix, precision, recall, and F1 scores for each class.</li>
</ul></li>
</ul>
<div id="8114a37c-c503-48d0-879b-196e6b0751f3" class="cell" data-tags="[]" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model(X, Y, input_size, hidden_size, output_size, num_iterations, learning_rate):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    parameters <span class="op">=</span> initialize_parameters(input_size, hidden_size, output_size)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_iterations):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        A2, cache <span class="op">=</span> forward_propagation(X, parameters)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        cost <span class="op">=</span> compute_cost(A2, Y)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        gradients <span class="op">=</span> backward_propagation(parameters, cache, X, Y)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        parameters <span class="op">=</span> update_parameters(parameters, gradients, learning_rate)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parameters</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="function-predict" class="level4">
<h4 class="anchored" data-anchor-id="function-predict">8. Function: <code>predict</code></h4>
<ul>
<li><strong>Purpose</strong>: This function performs a forward pass using the trained network parameters and computes the output predictions for the input data <code>X</code>.</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>X</code>: The input features array.</li>
<li><code>parameters</code>: A dictionary containing the trained weights and biases of the neural network.</li>
</ul></li>
<li><strong>Process</strong>:
<ul>
<li><strong>Forward Pass</strong>: Utilizes the <code>forward_propagation</code> function, which performs the entire sequence of computations from the input layer through hidden layers to the output layer.</li>
<li><strong>Softmax Output</strong>: The final layer’s activations (<code>A2</code>) are passed through a softmax function during the forward pass, which outputs probability distributions over the classes.</li>
<li><strong>Prediction</strong>: The function uses <code>np.argmax</code> on <code>A2</code> across the first dimension (<code>axis=0</code>) to determine the index of the highest probability in each column, which corresponds to the class label prediction.</li>
</ul></li>
<li><strong>Returns</strong>:
<ul>
<li><code>predictions</code>: An array of predicted class labels for each example in <code>X</code>.</li>
</ul></li>
</ul>
<div id="97779c1d-6165-480d-ac2a-27a24bb4541c" class="cell" data-tags="[]" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict(X, parameters):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" Perform a forward pass using trained parameters and return the predicted labels. """</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    _, cache <span class="op">=</span> forward_propagation(X, parameters)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    predictions <span class="op">=</span> np.argmax(cache[<span class="st">'A2'</span>], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> predictions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="function-accuracy" class="level4">
<h4 class="anchored" data-anchor-id="function-accuracy">9. Function: <code>accuracy</code></h4>
<ul>
<li><strong>Purpose</strong>: Calculate the accuracy of the predicted labels against the true labels.</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>predictions</code>: The array of predicted labels returned from the <code>predict</code> function.</li>
<li><code>labels</code>: The actual true labels against which predictions are to be evaluated. These labels are typically in a one-hot encoded format.</li>
</ul></li>
<li><strong>Process</strong>:
<ul>
<li><strong>Label Conversion</strong>: Converts the one-hot encoded <code>labels</code> array into integer class labels using <code>np.argmax(labels, axis=0)</code>, which finds the class with the highest probability (true class) for each example.</li>
<li><strong>Accuracy Computation</strong>: Computes the mean of the boolean values where predicted labels match the true labels (<code>predictions == labels</code>). The <code>np.mean</code> function calculates the fraction of correct predictions, effectively giving the model’s accuracy.</li>
</ul></li>
<li><strong>Returns</strong>:
<ul>
<li>The accuracy as a float, representing the percentage of correctly predicted labels.</li>
</ul></li>
</ul>
<div id="2b572211-f377-4a3d-b571-96ec379a30e0" class="cell" data-tags="[]" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> accuracy(predictions, labels):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" Calculate the accuracy of predictions by comparing to the true labels. """</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> np.argmax(labels, axis<span class="op">=</span><span class="dv">0</span>)  <span class="co"># Convert one-hot encoded labels back to single digit labels</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(predictions <span class="op">==</span> labels)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="function-store_updates" class="level4">
<h4 class="anchored" data-anchor-id="function-store_updates">10. Function: <code>store_updates</code></h4>
<ul>
<li><strong>Purpose</strong>: Collects and stores the norms of the weights and biases as well as their gradient norms at a given iteration. This is useful for monitoring and debugging the training process.</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>iteration</code>: The current iteration number in the training loop.</li>
<li><code>parameters</code>: A dictionary of the current weights (<code>W1</code>, <code>W2</code>) and biases (<code>b1</code>, <code>b2</code>) of the network.</li>
<li><code>gradients</code>: A dictionary of the gradients (<code>dW1</code>, <code>dW2</code>, <code>db1</code>, <code>db2</code>) computed during the backward propagation step.</li>
</ul></li>
<li><strong>Process</strong>:
<ul>
<li><strong>Norm Calculation</strong>: Computes the Frobenius norm (default norm for matrices in <code>numpy.linalg.norm</code>) for each parameter and its corresponding gradient. This measure helps in understanding the magnitude of parameters and their rate of change.</li>
<li><strong>Data Structuring</strong>: Organizes these norms into a dictionary, with keys indicating the parameter or gradient name followed by ’_norm’ or ’_grad_norm’ and the value being the calculated norm.</li>
<li><strong>Iteration Recording</strong>: Adds the current iteration number to the dictionary for tracking purposes.</li>
</ul></li>
<li><strong>Returns</strong>:
<ul>
<li><code>update_info</code>: A dictionary containing the norms of parameters, their gradient norms, and the iteration number.</li>
</ul></li>
</ul>
<div id="0bce49b3-2c47-424b-94ac-b1d9b603c57d" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> store_updates(iteration, parameters, gradients):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    update_info <span class="op">=</span> {}</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key <span class="kw">in</span> parameters:</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        update_info[key <span class="op">+</span> <span class="st">"_norm"</span>] <span class="op">=</span> np.linalg.norm(parameters[key])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        update_info[key <span class="op">+</span> <span class="st">"_grad_norm"</span>] <span class="op">=</span> np.linalg.norm(gradients[<span class="st">'d'</span> <span class="op">+</span> key])</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    update_info[<span class="st">'iteration'</span>] <span class="op">=</span> iteration</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> update_info</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="function-model" class="level4">
<h4 class="anchored" data-anchor-id="function-model">11. Function: <code>model</code></h4>
<ul>
<li><strong>Purpose</strong>: Executes the full training cycle of the neural network, including forward and backward propagation, parameter updates, and periodically evaluating the model on a validation dataset.</li>
<li><strong>Parameters</strong>:
<ul>
<li><code>X</code>, <code>Y</code>: Training dataset features and labels.</li>
<li><code>X_val</code>, <code>Y_val</code>: Validation dataset features and labels.</li>
<li><code>input_size</code>, <code>hidden_size</code>, <code>output_size</code>: Dimensions for the input layer, hidden layer, and output layer, respectively.</li>
<li><code>num_iterations</code>: Total number of iterations for training the model.</li>
<li><code>learning_rate</code>: Step size at each iteration for updating the parameters.</li>
</ul></li>
<li><strong>Process</strong>:
<ul>
<li><strong>Initialization</strong>: Parameters are initialized using <code>initialize_parameters</code>.</li>
<li><strong>Training Loop</strong>:
<ul>
<li><strong>Forward Propagation</strong>: Calculates network outputs for the training data.</li>
<li><strong>Cost Calculation</strong>: Computes the cross-entropy cost, which guides the optimization.</li>
<li><strong>Backward Propagation</strong>: Calculates gradients of the cost with respect to parameters.</li>
<li><strong>Parameter Update</strong>: Adjusts the network parameters based on gradients.</li>
<li><strong>Validation Evaluation</strong>: Every 100 iterations, the function evaluates the model’s performance on the validation set using the <code>predict</code> and <code>accuracy</code> functions.</li>
</ul></li>
<li><strong>Monitoring</strong>: Stores updates on parameter norms and validation accuracy for monitoring progress.</li>
</ul></li>
<li><strong>Returns</strong>:
<ul>
<li><code>parameters</code>: The trained network parameters.</li>
<li><code>updates</code>: A list of dictionaries detailing the parameter norms and gradient norms at specified intervals.</li>
<li><code>accuracy_records</code>: A list of dictionaries containing accuracy measurements on the validation set at specified intervals.</li>
</ul></li>
</ul>
<div id="a22c54a4-eba4-4159-a97c-3122a60046b7" class="cell" data-tags="[]" data-execution_count="14">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> model(X, Y, X_val, Y_val, input_size, hidden_size, output_size, num_iterations, learning_rate):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    parameters <span class="op">=</span> initialize_parameters(input_size, hidden_size, output_size)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    updates <span class="op">=</span> []</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    accuracy_records <span class="op">=</span> []</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_iterations):</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        A2, cache <span class="op">=</span> forward_propagation(X, parameters)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        cost <span class="op">=</span> compute_cost(A2, Y)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        gradients <span class="op">=</span> backward_propagation(parameters, cache, X, Y)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        parameters <span class="op">=</span> update_parameters(parameters, gradients, learning_rate)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span>:  <span class="co"># Store updates every 100 iterations</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>            updates.append(store_updates(i, parameters, gradients))</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Evaluate model on validation set</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>            predictions <span class="op">=</span> predict(X_val, parameters)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>            acc <span class="op">=</span> accuracy(predictions, Y_val)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>            accuracy_records.append({<span class="st">'iteration'</span>: i, <span class="st">'accuracy'</span>: acc})</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parameters, updates, accuracy_records</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Model Training</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>X_val, Y_val <span class="op">=</span> X_test.T, Y_test.T</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>trained_parameters, update_records, accuracy_records <span class="op">=</span> model(X_train.T, Y_train.T, X_val, Y_val, input_size<span class="op">=</span><span class="dv">4</span>, hidden_size<span class="op">=</span><span class="dv">5</span>, output_size<span class="op">=</span><span class="dv">3</span>, num_iterations<span class="op">=</span><span class="dv">1000</span>, learning_rate<span class="op">=</span><span class="fl">0.01</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="model-training" class="level4">
<h4 class="anchored" data-anchor-id="model-training">12. Model Training</h4>
<ul>
<li><strong>Validation Setup</strong>: Assumes <code>X_test</code> and <code>Y_test</code> are defined and uses these as the validation dataset (<code>X_val</code>, <code>Y_val</code>).</li>
<li><strong>Training Execution</strong>: The model is trained using the training set and periodically evaluated using the validation set to monitor performance and avoid overfitting.</li>
</ul>
<div id="ca05db9d-23cb-40f9-8430-8a686fc06528" class="cell" data-tags="[]" data-execution_count="15">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>X_val, Y_val <span class="op">=</span> X_test.T, Y_test.T</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>trained_parameters, update_records, accuracy_records <span class="op">=</span> model(X_train.T, Y_train.T, X_val, Y_val, input_size<span class="op">=</span><span class="dv">4</span>, hidden_size<span class="op">=</span><span class="dv">5</span>, output_size<span class="op">=</span><span class="dv">3</span>, num_iterations<span class="op">=</span><span class="dv">1000</span>, learning_rate<span class="op">=</span><span class="fl">0.01</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="visualization-model-accuracy-over-iterations" class="level1">
<h1>Visualization: Model Accuracy over Iterations</h1>
<ul>
<li><strong>X-axis</strong>: Represents the training iterations, indicating the points in training at which the model’s accuracy is evaluated.</li>
<li><strong>Y-axis</strong>: Shows the accuracy percentage, providing a measure of how well the model predicts the correct classifications on the validation set at each recorded iteration.</li>
<li><strong>Line Plot</strong>: The line connecting the data points demonstrates the trend of accuracy improvement or fluctuations throughout the training process.</li>
</ul>
<div id="29bb02c5-6487-4e51-8ba7-65036ae46469" class="cell" data-tags="[]" data-execution_count="16">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>df_updates <span class="op">=</span> pd.DataFrame(update_records)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>df_accuracy <span class="op">=</span> pd.DataFrame(accuracy_records)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting model accuracy</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>plt.plot(df_accuracy[<span class="st">'iteration'</span>], df_accuracy[<span class="st">'accuracy'</span>], label<span class="op">=</span><span class="st">'Accuracy'</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Iteration'</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Accuracy (%)'</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Model Accuracy over Iterations'</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Back-Propagation-Neural-Network-NumPy_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="visualization-parameter-and-gradient-norms-over-iterations" class="level1">
<h1>Visualization: Parameter and Gradient Norms over Iterations</h1>
<ul>
<li><strong>Chart Overview</strong>: This chart visualizes the norms of network parameters and their gradients throughout the training process, showing the magnitude changes over iterations.</li>
<li><strong>X-axis</strong>: Represents the training iterations, capturing the points in training where the norms are computed and recorded.</li>
<li><strong>Y-axis</strong>: Displays the norms of the parameters and gradients, providing insight into the scale of parameter values and the rate at which they are updated.</li>
<li><strong>Line Plot</strong>: Each line on the plot corresponds to a different parameter or gradient, with variations in the line styles or colors distinguishing between them.</li>
<li><strong>Purpose of Visualization</strong>: Helps in monitoring the training dynamics, specifically the magnitude of updates to parameters and gradients, which can inform adjustments to learning rates or highlight potential issues like vanishing or exploding gradients.</li>
</ul>
<div id="67bdbb1a-0a3b-47c6-849a-4760b65756bc" class="cell" data-tags="[]" data-execution_count="17">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting parameter norms</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> column <span class="kw">in</span> df_updates.columns:</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"norm"</span> <span class="kw">in</span> column:</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        plt.plot(df_updates[<span class="st">'iteration'</span>], df_updates[column], label<span class="op">=</span>column)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Iteration'</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Norm'</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Parameter and Gradient Norms over Iterations'</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Back-Propagation-Neural-Network-NumPy_files/figure-html/cell-18-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="model-performance-metrics" class="level1">
<h1>Model Performance metrics</h1>
<ul>
<li><strong>Model Accuracy</strong>: Represents the overall percentage of correct predictions made by the model on the test set. This single metric provides a quick snapshot of model effectiveness.</li>
<li><strong>Confusion Matrix</strong>: A tabular representation that shows the actual versus predicted classifications for each class. It helps identify which classes are most frequently confused with others, indicating areas where the model may require improvement.</li>
<li><strong>Precision, Recall, and F1-Score</strong>: These metrics provide a deeper dive into the model’s performance by class:
<ul>
<li><strong>Precision</strong>: The ratio of true positive predictions to the total predicted positives, indicating the accuracy of positive predictions.</li>
<li><strong>Recall</strong>: The ratio of true positive predictions to the actual positives, showing the model’s ability to detect positive instances.</li>
<li><strong>F1-Score</strong>: The harmonic mean of precision and recall, providing a single metric that balances both the precision and recall, which is particularly useful when the class distribution is uneven.</li>
</ul></li>
<li><strong>Class Labels</strong>: Each metric is reported per class (Setosa, Versicolor, Virginica), which provides insights into the model’s performance on specific types of iris flowers.</li>
</ul>
<p>The combination of overall accuracy with precision, recall, and F1-score for each class offers a comprehensive view of the model’s performance, highlighting strengths and pinpointing areas for potential refinement.</p>
<div id="ae1e5930-4534-4a17-828c-09764aa8d563" class="cell" data-tags="[]" data-execution_count="19">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>test_predictions <span class="op">=</span> predict(X_test.T, trained_parameters)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>test_accuracy <span class="op">=</span> accuracy(test_predictions, Y_test.T)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Model Accuracy on Test Set: </span><span class="sc">{</span>test_accuracy <span class="op">*</span> <span class="dv">100</span><span class="sc">:.2f}</span><span class="ss">%"</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> confusion_matrix(predictions, labels):</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> <span class="bu">len</span>(np.unique(labels))  <span class="co"># Number of classes</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    conf_matrix <span class="op">=</span> np.zeros((K, K), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(labels)):</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        conf_matrix[labels[i]][predictions[i]] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> conf_matrix</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> precision_recall_f1(conf_matrix):</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    precision <span class="op">=</span> np.diag(conf_matrix) <span class="op">/</span> np.<span class="bu">sum</span>(conf_matrix, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    recall <span class="op">=</span> np.diag(conf_matrix) <span class="op">/</span> np.<span class="bu">sum</span>(conf_matrix, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    f1_scores <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (precision <span class="op">*</span> recall) <span class="op">/</span> (precision <span class="op">+</span> recall)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> precision, recall, f1_scores</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>true_labels <span class="op">=</span> np.argmax(Y_test, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Confusion Matrix</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>conf_matrix <span class="op">=</span> confusion_matrix(test_predictions, true_labels)</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>precision, recall, f1_scores <span class="op">=</span> precision_recall_f1(conf_matrix)</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>metrics_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Precision'</span>: precision,</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Recall'</span>: recall,</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="st">'F1-Score'</span>: f1_scores</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>class_labels <span class="op">=</span> [<span class="st">'Setosa'</span>, <span class="st">'Versicolor'</span>, <span class="st">'Virginica'</span>]</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>metrics_df.index <span class="op">=</span> class_labels</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Confusion Matrix:</span><span class="ch">\n</span><span class="st">"</span>, pd.DataFrame(conf_matrix, index<span class="op">=</span>class_labels, columns<span class="op">=</span>class_labels))</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Metrics per class:"</span>)</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>metrics_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Model Accuracy on Test Set: 96.67%
Confusion Matrix:
             Setosa  Versicolor  Virginica
Setosa          10           0          0
Versicolor       0           8          1
Virginica        0           0         11

Metrics per class:</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="19">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Precision</th>
<th data-quarto-table-cell-role="th">Recall</th>
<th data-quarto-table-cell-role="th">F1-Score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Setosa</td>
<td>1.000000</td>
<td>1.000000</td>
<td>1.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Versicolor</td>
<td>1.000000</td>
<td>0.888889</td>
<td>0.941176</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Virginica</td>
<td>0.916667</td>
<td>1.000000</td>
<td>0.956522</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>